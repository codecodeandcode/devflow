这个问题问得非常好 👍
你现在已经在思考 **“副作用应该在哪里执行”** 了，这是架构层面的思考。

我们对比三种方式：

1. ✅ `after()`（Server Component 内）
2. ✅ `Promise.all()`（请求阶段并行执行）
3. ✅ Client Component + `useEffect()` 调 Server Action

我帮你从 **执行时机、SEO、性能、一致性、用户体验** 五个维度讲清楚。

---

# 一、你现在用的是 `after()`

```ts
after(async () => {
  await incrementViews({ questionId: id });
});
```

## ✅ 它的行为

* 页面数据先返回
* HTML 先流式发送
* 响应完成后再执行 incrementViews
* 不阻塞页面渲染

---

## ✅ 优点

### 1️⃣ 不影响 TTFB（首字节时间）

页面渲染不会被「更新 view」阻塞。

### 2️⃣ SEO 友好

爬虫访问时也会执行（因为是服务器端）。

### 3️⃣ 不依赖客户端 JS

就算用户禁用 JS 也会增加 view。

### 4️⃣ 逻辑集中在服务端

更干净、更可控。

---

## ❌ 缺点

### 1️⃣ 不是 100% 保证执行

如果：

* Server crash
* Edge runtime 终止
* 请求中断

可能执行不到。

（但概率很低）

---

# 二、如果用 Promise.all()

```ts
const [{ success, data }] = await Promise.all([
  getQuestion(...),
  incrementViews(...)
]);
```

---

## ✅ 优点

* 一定会执行
* 和数据请求并行

---

## ❌ 缺点（致命）

### ❗ 会影响页面返回速度

因为：

```
必须等 incrementViews 完成
页面才返回
```

哪怕只是 +1 操作。

在高并发下：

数据库写操作会拖慢所有页面响应。

---

# 三、如果用 Client + useEffect

```tsx
useEffect(() => {
  incrementViews(...)
}, [])
```

---

## ✅ 优点

* 完全不影响服务器响应时间
* 页面立即返回
* 最不阻塞

---

## ❌ 缺点

### 1️⃣ 依赖 JS

如果用户禁用 JS → 不增加 view

### 2️⃣ SEO 不统计

搜索引擎爬虫通常不执行 JS

### 3️⃣ 可被轻易刷

前端逻辑更容易被绕过

### 4️⃣ 页面刷新会重复统计

更难控制

---

# 四、三种方案对比表

| 方案          | 是否阻塞页面 | SEO 统计 | 依赖 JS | 稳定性  |
| ----------- | ------ | ------ | ----- | ---- |
| after()     | ❌ 不阻塞  | ✅ 是    | ❌ 不依赖 | ⭐⭐⭐⭐ |
| Promise.all | ✅ 阻塞   | ✅ 是    | ❌ 不依赖 | ⭐⭐⭐  |
| useEffect   | ❌ 不阻塞  | ❌ 否    | ✅ 依赖  | ⭐⭐   |

---

# 五、在真实生产环境怎么做？

大厂通常不会直接这样写。

真正专业做法是：

---

## 🚀 方案 1：写入 Redis

访问时：

```
Redis INCR question:123:views
```

然后：

* 定时批量写回数据库
* 不在页面逻辑里直接写 DB

优点：

* 极快
* 不阻塞
* 可抗高并发

---

## 🚀 方案 2：异步队列

访问时：

```
push job 到队列
```

worker 异步写数据库。

---

# 六、那你现在用 after 对不对？

对于：

* 个人项目
* 中小型应用
* 日访问 < 1万

👉 **after() 是最平衡的选择**

它比 useEffect 更安全
比 Promise.all 更高效

---

# 七、什么时候不能用 after？

* Edge Runtime 不支持
* 需要 100% 保证写入
* 需要精确计费统计

---

# 八、总结一句话

```
Promise.all = 阻塞式副作用
useEffect = 客户端副作用
after = 服务端非阻塞副作用（最佳平衡）
```

---

# 九、你的项目现在阶段

你现在的做法：

```ts
after(async () => {
  await incrementViews(...)
});
```

是非常合理的。

已经是一个“思路正确的后端设计”。

---

如果你愿意，我可以讲更深入一点：

* 如何防止刷新刷 view？
* 如何实现“一个 IP 一天只算一次”？
* 如何做真实的防刷浏览系统？
* 如何做高并发 view 统计架构？

这块是系统设计面试常考题 🔥
